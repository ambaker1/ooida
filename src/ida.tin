# ida.tcl
################################################################################
# IDA class definition

# Copyright (C) 2024 Alex Baker, ambaker1@mtu.edu
# All rights reserved. 

# See the file "LICENSE" in the top level directory for information on usage, 
# redistribution, and for a DISCLAIMER OF ALL WARRANTIES.
################################################################################

# Methods:
# configure: Access/modify the IDA configuration
# wipe: Clear out the IDA object of data (keep settings)
# add: Add a point to the IDA
# remove: Remove a point from the IDA
# next: Get the next intensity measure 
# update: Update existing jobs
# run: Run the IDA 
# table: Get IDA data

oo::class create ::ooida::ida {
    superclass ::vutil::GarbageCollector
    # Class variables
    variable config; # Settings array
    variable idata; # Table object that stores all the IDA data
    variable im2job; # Mapping of intensity to job tag for active jobs
    variable stage; # IDA stage integer (0-4)
    variable capacity; # List of lower and upper bound on capacity
    variable queue; # Ordered list of intensities to run
    
    # ida new/create --
    #
    # Create an IDA object
    # 
    # Syntax:
    # ida new $varName <$option $value ...>
    # ida create $name $varName <$option $value ...>
    # 
    # Arguments:
    # varName       Variable to store object in for garbage collection.
    # name          Name of IDA object.
    # option        Settings option (see "my ApplySettings")
    # value         Value for settings option (see "my ApplySettings")
    
    constructor {varName args} {
        # Check arity
        if {[llength $args] % 2 == 1} {
            return -code error "wrong # of args: want option-value pairs"
        }
        # Define default settings
        set config(-huntup) {Geometric 1.0 2.0}
        set config(-precision) {0.5 1.0}
        set config(-limits) {0.0 Inf} 
        set config(-collapse) code 
        
        # Apply user defined configuration inputs
        my configure {*}$args
        
        # Initialize data structures
        ::ndlist::table new idata
        $idata define keyname intensity
        $idata define fields jobTag
        set im2job ""; # Dictionary mapping for asyncronous jobs
        set stage 0; # Stage of algorithm
        set queue ""; # Queue of inputs
        
        # Call the superclass constructor
        next $varName
    }
    
    # Modify <cloned> method to handle object references.
    method <cloned> {sourceObject} {
        # Copy over everything
        next $sourceObject
        # The variable "idata" is simply a reference to a global object.
        # Therefore, it also must be copied.
        $idata --> idata
    }
    
    # $ida configure --
    #
    # Queries or updates configuration settings.
    # If no arguments, returns entire settings dictionary.
    # If one argument, returns the settings for that option.
    # If an even number of arguments, defines the settings.
    #
    # Syntax:
    # $ida configure
    # $ida configure $option
    # $ida configure $option $value ...
    # 
    # Arguments:
    # option        Settings option
    # value         Value for settings option
    
    method configure {args} {
        # Switch for arity (based on how fconfigure works with Tcl)
        if {[llength $args] == 0} {
            # Query all settings
            return [array get config]
        } elseif {[llength $args] == 1} {
            # Query specific option
            set option [lindex $args 0]
            if {![info exists config($option)]} {
                return -code error "Unknown option \"$option\""
            }
            return $config($option)
        } elseif {[llength $args] % 2 == 1} {
            return -code error "wrong # of args: want option-value pairs"
        }
        # Loop through settings, checking validity
        dict for {option value} $args {
            # Switch for option, with basic config checks
            switch $option {
                -huntup { # -huntup defines initial IDA behavior
                    #   Geometric multiplies the last IM by the step.
                    #   Quadratic adds the step to the IM gap.
                    #   Linear simply steps by the step size.
                    # Example: -huntup "Geometric 0.1 2.0"
                    if {[llength $value] != 3} {
                        return -code error "wrong # of -huntup args"
                    }
                    lassign $value type start step
                    if {$type ni {Geometric Quadratic Linear}} {
                        return -code error "Try Geometric, Quadratic, or Linear"
                    }
                    if {![string is double -strict $start]} {
                        return -code error "Start must be number"
                    } elseif {$start <= 0.0} {
                        return -code error "Start must be greater than zero"
                    }
                    if {![string is double -strict $step]} {
                        return -code error "Step must be number"
                    } elseif {$type eq {Geometric} && $step <= 1.0} {
                        return -code error "Geometric step must be > 1.0"
                    } elseif {$type eq {Quadratic} && $step < 0.0} {
                        return -code error "Quadratic step must be >= 0.0"
                    } elseif {$type eq {Linear} && $step < 0.0} {
                        return -code error "Linear step must be >= 0.0"
                    }
                }
                -collapse { # -collapse defines the field used for collapses
                    # Example: -collapse code
                    # Check existing data to verify that the field exists.
                    foreach key [$idata keys] {
                        if {![$idata exists value $key $value]} {
                            return -code error "-collapse field \"$value\"\
                                    not found in existing data"
                        }
                    }
                }
                -precision { # -precision defines the hunt and fill precision.
                    # Example: -precision "0.5 1.0"
                    if {[llength $value] != 2} {
                        return -code error "wrong # of -precision args"
                    }
                    lassign $value hunt fill
                    if {![string is double -strict $hunt] || $hunt <= 0.0} {
                        return -code error "hunt precision must be number > 0"
                    }
                    if {![string is double -strict $fill] || $fill <= 0.0} {
                        return -code error "fill precision must be number > 0"
                    }
                }
                -limits { # -limits defines bounds of refining
                    # Example: -limits "0 Inf"
                    if {[llength $value] != 2} {
                        return -code error "wrong # of -limits args"
                    }
                    lassign $value min max
                    if {$min > $max} {
                        return -code error "min must be <= max"
                    }
                    if {$min < 0.0} {
                        return -code error "min out of range"
                    }
                }
                default {
                    return -code error "Unknown setting \"$option\""
                }
            }; # end switch
        }
        # Merge into main settings
        array set config {*}$args
        # Clear the queue
        set queue ""
        return
    }

    # $ida add --
    #
    # Adds a single point to the IDA, whether it is a tentative or final.
    #
    # Syntax:
    # $ida add $im <$jobTag> <$field $value ...>
    #
    # Arguments:
    # im                    Intensity measure to add
    # jobTag                Job tag for intensity measure (mpjobs)
    # field value...        IDA results, mutually exclusive with $jobTag

    method add {im args} {
        # Validate input (intensity measure must be non-negative)
        if {$im < 0} {
            return -code error "intensity measure must be >= 0.0"
        }
        # Check arity
        if {[llength $args] == 0} {
            return -code error "must provide job tag or analysis results"
        }
        if {[llength $args] % 2 == 1 && [llength $args] != 1} {
            return -code error "wrong # args: must be \
                    \"[self] add im field value ...\""
        }

        # Trim queue if pulling from queue
        if {$im == [lindex $queue 0]} {
            set queue [lrange $queue 1 end]
        } else {
            # If not pulling from queue, reset the queue.
            set queue ""
        }
        
        # Switch for job/result cases
        # --------------------------------------------------------------
        if {[llength $args] == 1} {
            # Adding a job, does not change stage
            set jobTag [lindex $args 0]
            $idata set $im jobTag $jobTag
            # Check status of job
            set status [::mpjobs::getJobStatus $jobTag]
            if {$status == 0} {
                # Run the job, either in series or in parallel
                ::mpjobs::runJobs $jobTag
                set status [::mpjobs::getJobStatus $jobTag]
            }
            if {$status == 1} {
                # Running asyncronously. Return.
                dict set im2job $im $jobTag
                return
            } elseif {$status == 3} {
                # Job resulted in error
                return -code error "Error in job $jobTag"
            }; # end switch job status
            # Results come from job
            set results [::mpjobs::getJobResults $jobTag]
        } else {
            # No job, results come from arguments
            $idata set $im jobTag ""
            set results $args
        }
        # Verify that the results include collapse information
        if {![dict exists $results $config(-collapse)]} {
            return -code error "missing collapse information"
        }
        # If analysis resulted in collapse, clear the queue.
        if {[dict get $results $config(-collapse)]} {
            set queue ""
        }
        # Save results
        $idata set $im {*}$results
        return
    }
    
    # $ida remove --
    #
    # Remove a point from the IDA curve
    #
    # Syntax:
    # $ida remove $im
    #
    # Arguments:
    # im        Intensity measure value associated with IDA curve point
    
    method remove {im} {
        if {[$idata exists key $im]} {
            $idata remove key $im
            dict unset im2job $im
        }
        # Clear the queue
        set queue ""
        return
    }
    
    # my UpdateIDA --
    #
    # Updates the queue
    
    method UpdateIDA {} {
        # Sort the IDA data, and get configuration settings
        $idata sort -real; # sorts intensity measures in increasing order
        lassign $config(-limits) lowerLimit upperLimit
        lassign $config(-precision) huntPrecision fillPrecision
        lassign $config(-huntup) huntType huntStart huntStep
        
        # Get list of all collapse cases using collapse field
        set collapses [$idata query "@$config(-collapse)"]
        
        # Determine bounds on capacity, and preliminary IDA stage
        # --------------------------------------------------------------
        if {[llength $collapses] == 0} {
            # Collapse not reached
            set maxCapacity Inf
            if {[$idata height] == 0} {
                set minCapacity 0.0
            } else {
                set minCapacity [lindex [$idata keys] end]
            }
            # Determine preliminary stage
            if {$capacity == 0} {
                set stage 0
            } else {
                set stage 1
            }
        } elseif {
            # Collapse reached
            set maxCapacity [lindex $collapses 0]
            set i [lsearch -sorted -exact -real [$idata keys] $maxCapacity]
            if {$i == 0} {
                set minCapacity 0.0
            } else {
                set minCapacity [lindex [$idata keys] $i-1]
            }
            # Determine preliminary stage
            if {($maxCapacity - $minCapacity) > $huntPrecision} {
                set stage 2
            } else {
                set stage 3
            }
        }
        # Save capacity bounds
        set capacity [list $minCapacity $maxCapacity]
        
        # Modify the stage for partial IDA limits (see Figure 3 in docs)
        # --------------------------------------------------------------
        # Column A: Skip stages 2 and 3 if max capacity is <= lower limit.
        if {$stage in {2 3} && $maxCapacity <= $lowerLimit} {
            set stage 4
        }
        # Column B & C: Skip stage 3 if min capacity <= lower limit.
        if {$stage == 3 && $minCapacity <= $lowerLimit} {
            set stage 4
        }
        # Columns D & E: No change        
        # Column F: Skip to stage 3 if min capacity is > upper limit 
        if {$stage in {1 2} && $minCapacity > $upperLimit} {
            set stage 3
        }
        
        # Generate the queue based on the stage of the algorithm
        # --------------------------------------------------------------
        if {$stage == 0} {
            # Stage 0: Initialization
            set queue $huntStart
        } elseif {$stage == 1} {
            # Stage 1: Hunt-up
            set im1 [lindex [$idata keys] end-1]
            set im2 [lindex [$idata keys] end]
            switch $huntType {
                Geometric {
                    set queue [expr {$im2 * $huntStep}]
                }
                Quadratic {
                    set queue [expr {$im2 + ($im2 - $im1) + $huntStep}]
                }
                Linear {
                    set queue [expr {$im2 + $huntStep}]
                }
            }
        } elseif {$stage == 2} {
            # Stage 2: Bracketing
            set queue [expr {($minCapacity + $maxCapacity)/2.0}]
        } elseif {$stage == 3} {
            # Stage 3: Fill-in
            # Get list of intensity measures to fill
            if {$minCapacity <= $upperLimit} {
                # Zone 2
                set i [lsearch -sorted -real -bisect [$idata keys] $minCapacity]
                set imList [lrange [$idata keys] 0 $i]
            } else {
                # Zone 3 ($capacity > $upperLimit)
                set i [lsearch -sorted -real -bisect [$idata keys] $upperLimit]
                set imList [lrange [$idata keys] 0 $i+1]
            }
            # Generate queue for fill stage
            set queue [::ooida::GenerateQueue $imList $fillPrecision]
        }
        # Check for completion criteria
        if {[llength $queue] == 0} {
            set stage 4
            set queue -2
        }
    }
    
    # $ida next --
    #
    # Updates the IDA and gets the next intensity measure. 
    # Returns -1 if number of active jobs exceeds allowed for stage
    # Returns -2 if IDA curve is complete.
    #
    # Syntax:
    # $ida next
    
    method next {} { 
        # If no queue exists update IDA.
        if {[llength $queue] == 0} {
            my UpdateIDA
        }
        # Only allow parallelization of the record in the fill-in stage
        if {[dict size $im2job] > 0 && $stage != 3} {
            return -1
        }
        # Return the first element in the queue
        return [lindex $queue 0]
    }
    
    # $ida complete --
    #
    # Returns true if the IDA curve is complete
    # Same as checking if queue is -2, or stage is 4.
    #
    # Syntax:
    # $ida complete
    
    method complete {} {
        expr {[my next] == -2}
    }
    
    # $ida stage --
    #
    # Return the current stage of the IDA algorithm
    #
    # Syntax:
    # $ida stage
    
    method stage {} {
        my next; # updates IDA if needed
        return $stage
    }
    
    # $ida capacity --
    #
    # Returns the lower and upper bounds on capacity
    
    method capacity {} {
        my next; # updates IDA if needed
        return $capacity
    }
    
    # $ida update --
    #
    # Updates active IDA jobs from job board framework
    #
    # Syntax:
    # $ida update
    
    method update {} {     
        # Guard clause for no jobs
        if {[dict size $im2job] == 0} {
            return
        }
        # Add results for any completed jobs
        ::mpjobs::updateJobs [dict values $im2job]
        dict for {im jobTag} $im2job {
            set status [::mpjobs::getJobStatus $jobTag]
            if {$status == 0} {
                # This should not occur.
                return -code error "job $jobTag is posted but not running"
            } elseif {$status == 1} {
                # Job is still active
                continue
            } elseif {$status == 2} {
                # Job is complete
                my add $im {*}[::mpjobs::getJobResults $jobTag]
            } else {
                # Job resulted in error
                return -code error "Error in job $jobTag"
            }; # end switch job status
        }; # end dict for jobname and im
        return
    }
    
    # $ida run --
    #
    # Run the IDA. The body must evaluate to a jobTag or result list.
    # Acts like a normal Tcl loop, but "continue" is not very meaningful.
    #
    # Syntax:
    # $ida run $imVar $body
    #
    # Arguments:
    # imVar     Variable to pass the intensity measure to
    # body      Body of run loop. Must evaluate to a jobTag or a result dict
    
    method run {imVar body} {
        upvar $imVar im
        while {1} {
            my update
            set im [my next]
            if {$im == -1} {
                after 10; # Wait a split second
                continue
            } elseif {$im == -2} {
                break
            }
            # Add point, returning on error and return
            try {
                my add $im {*}[uplevel 1 $body]
            } on return {result options} {
                return -options $options $result
            } on error {result options} {
                return -options $options $result
            }
        }
        return
    }
    
    # $ida table --
    #
    # Return the IDA table data, sorted in increasing intensity measure.
    # First columns are "intensity" and "jobTag", remaining columns are results.
    #
    # Syntax:
    # $ida table
    
    method table {} {
        my next; # updates the IDA if needed
        return [$idata]
    }
}; # end class definition

# Finally, provide the package
package provide ooida @VERSION@
